// Copyright 2017 - 2020 Nash Muhandes
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//===========================================================================
//
// SpriteShadow
//
// Sprite-Based Actor Shadows
//
// Written by Nash Muhandes
//
// Feel free to use this in your mods. No need to ask for my permission!
//
//===========================================================================


//===========================================================================
//
//
//
//===========================================================================

class SpriteShadow : Actor
{
	Actor caster;

	//===========================================================================
	//
	//
	//
	//===========================================================================

	Default
	{
		RenderStyle "Stencil";
		StencilColor "Black";
		FloatBobPhase 0;
		+DONTSPLASH
		+NOBLOCKMAP
		+NOINTERACTION
		+NOTONAUTOMAP
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void Tick(void)
	{
		if (caster)
		{
			// filter shadow from yourself
			bool selfShadow =
			(
				caster is "PlayerPawn" &&
				players[consoleplayer].mo == caster &&
				players[consoleplayer].camera == players[consoleplayer].mo &&
				!(caster.player.cheats & CF_CHASECAM)
			);

			if (bInvisible = selfShadow)
			{
				// if self shadow, return early because it's pointless to keep processing from here
				return;
			}

			// match caster's sprites
			Sprite = caster.Sprite;
			Frame = caster.Frame;
			Angle = caster.Angle;
			Alpha = caster.Alpha * 0.5;
			Scale.X = caster.Scale.X;
			Scale.Y = caster.Scale.Y * 0.1;

			// SetOrigin is expensive, so let's do things ourselves
			Vector3 sPos =
			(
				caster.Pos.X + cos(players[consoleplayer].camera.Angle) * 0.01,
				caster.Pos.Y + sin(players[consoleplayer].camera.Angle) * 0.01,
				caster.FloorZ
			);
			LinkContext ctx;
			UnlinkFromWorld(ctx);
			SetXYZ(sPos);
			LinkToWorld(ctx);
		}
		else
		{
			Destroy();
			return;
		}
	}
}

//===========================================================================
//
//
//
//===========================================================================

class SpriteShadowCaster
{
	Actor mo;
	Actor shadow;
	bool hasShadow;
}

class SpriteShadowThinker : Thinker
{
	Array<SpriteShadowCaster> shadowCasters;
	CVar cvEnabled;
	CVar cvShadowDistance;

	override void Tick(void)
	{
		if (!cvEnabled || !cvShadowDistance)
		{
			ThrowAbortException("Cannot tick SpriteShadowThinker due to missing CVar references!");
			return;
		}

		// get the currently viewed camera
		Actor camera = players[consoleplayer].camera;
		if (!camera) return;

		BlockThingsIterator it = BlockThingsIterator.Create(camera, cvShadowDistance.GetFloat());
		while (it.Next())
		{
			let other = it.Thing;

			// shadow caster is close
			// use (distance - 1) so that it stays within the BlockThingsIterator's range
			if ((other.Distance3D(camera) - 1.0) < cvShadowDistance.GetFloat())
			{
				// currently qualify only monsters and players
				// to do: implement some kind of actor black/whitelist system
				bool valid =
				(
					other.bIsMonster ||
					other is "PlayerPawn"
				);

				if (!valid) continue;

				// prevent duplicate entries in the array
				bool isDuplicate = false;
				int i = 0;
				for (i = 0; i < shadowCasters.Size(); i++)
				{
					if (shadowCasters[i] && shadowCasters[i].mo == other)
					{
						isDuplicate = true;
						break;
					}
				}

				// add the actor into the shadow caster array
				if (!isDuplicate)
				{
					AddSpriteShadowCaster(other);

					// create the shadow actor
					if (!shadowCasters[i].hasShadow)
					{
						let shadow = SpriteShadow(Actor.Spawn("SpriteShadow", shadowCasters[i].mo.Pos, NO_REPLACE));
						if (shadow)
						{
							shadow.caster = shadowCasters[i].mo;
							shadowCasters[i].shadow = shadow;
							shadowCasters[i].hasShadow = true;
						}
					}
				}
			}
			// shadow caster is too far away
			else
			{
				for (int j = 0; j < shadowCasters.Size(); j++)
				{
					if (shadowCasters[j] && shadowCasters[j].mo == other)
					{
						if (shadowCasters[j].shadow) shadowCasters[j].shadow.Destroy();
						shadowCasters.Delete(j);
						break;
					}
				}
			}

			// array cleanup
			for (int k = 0; k < shadowCasters.Size(); k++)
			{
				if (shadowCasters[k] && !shadowCasters[k].shadow)
				{
					shadowCasters.Delete(k);
				}
			}
		}
	}

	void AddSpriteShadowCaster(Actor mo)
	{
		let sc = new("SpriteShadowCaster");
		if (sc)
		{
			sc.mo = mo;
			shadowCasters.Push(sc);
		}
	}

	void DoDestroy(void)
	{
		// kill all the shadows in this level
		shadowCasters.Clear();
		ThinkerIterator it = ThinkerIterator.Create("SpriteShadow");
		SpriteShadow shadow;
		while (shadow = SpriteShadow(it.Next()))
		{
			shadow.Destroy();
		}

		Destroy();
	}
}

//===========================================================================
//
//
//
//===========================================================================

class SpriteShadowHandler : EventHandler
{
	SpriteShadowThinker sst;

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void WorldLoaded(WorldEvent e)
	{
		if (!sst)
		{
			sst = new("SpriteShadowThinker");
			if (sst)
			{
				// cache the CVars
				sst.cvEnabled = CVar.GetCVar("spriteshadow_enabled", players[consoleplayer]);
				sst.cvShadowDistance = CVar.GetCVar("spriteshadow_distance", players[consoleplayer]);
			}
		}
	}

	override void WorldUnloaded(WorldEvent e)
	{
		if (sst)
		{
			sst.DoDestroy();
		}
	}
}
